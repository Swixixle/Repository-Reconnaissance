This is materially better: you corrected the contract drift, centralized verification semantics, and separated visibility vs. composite maturity (DCI vs RCI). Those are the right architectural moves.

But you still have one remaining red-line issue and two “must tighten” items before I’d treat Wave 1 as governance-stable.

Red-line issue: “verified_structural populated from verified claims + file index using pattern matching”

Pattern matching is fine only if it is scoped to structural outputs you already deterministically extract (e.g., target_howto.json route inventory, lockfiles, schema files). But your phrase implies:
	•	you are deriving structural buckets from claims and from a file index via patterns.

That can silently reintroduce heuristic creep.

What we need instead (hard rule)

verified_structural must be populated only from deterministic structural sources, not from narrative claims. That means:
	•	dependencies: from lockfiles / SBOM-like extraction (good)
	•	routes: from the existing route inventory extraction (target_howto or equivalent) — not from claims
	•	schemas: from Zod/OpenAPI schema detection output — not from claims
	•	enforcement: only if you have deterministic enforcement extractor output (middleware detection), with snippet hashes — not from claims

If a structural source doesn’t exist yet, the bucket stays empty and you add a known_unknown or “not detectable” note. No “best-effort inference-by-pattern.”

Directive: change verified_structural builder so its inputs are only those structural JSON outputs (or in-memory structural model) produced by your deterministic extractor layer.

⸻

Must tighten #1: DCI naming and definition

You now have:
	•	DCI v1 (Claims Visibility): 77.78% (hash-verified claims ratio)
	•	RCI: 36.59%
	•	DCI v2 reserved

This is acceptable if and only if you state prominently:
	•	DCI v1 is claim-evidence visibility, not system surface visibility
	•	DCI v2 will be structural surface visibility

Otherwise buyers will misread “DCI” as surface coverage.

Action: in executive and auditor outputs, label it exactly:
	•	DCI_v1_claim_visibility
	•	DCI_v2_structural_visibility (not implemented)

Drop the generic “DCI v1” wording in rendered reports.

⸻

Must tighten #2: Unknowns should not all be UNKNOWN forever

“All currently UNKNOWN” is fine for v1, but you need a pathway to flip to VERIFIED without inference.

Add a “Resolve With” hint already in unknowns. Good. Now add a deterministic upgrade rule:

Example:
	•	If repo contains terraform/ with aws_db_instance and storage_encrypted=true, then encryption_at_rest can move to VERIFIED with evidence anchors.
	•	If repo contains k8s/ingress.yaml with TLS section, then tls_termination can move to VERIFIED.
	•	If repo contains ExternalSecret manifests, then secret_management can move to VERIFIED.

Directive: implement this as optional deterministic detectors that only fire when exact known config artifacts exist. Otherwise remain UNKNOWN. No keyword matches.

⸻

Final gate: what I need from the agent (actual artifacts)

They still haven’t pasted the artifacts we asked for. Have them paste:
	1.	git diff --stat
	2.	git diff pta/verify_policy.py
	3.	git diff pta/adapter.py (especially verified_structural builder)
	4.	first ~120 lines of evidence_pack.v1.json
	5.	a claims.json excerpt showing snippet_hash_verified: true
	6.	first ~80 lines of DIFF_REPORT.md

No summaries.

⸻

What to tell the Replit agent now (copy/paste)

Two remaining requirements:
(1) verified_structural must be populated ONLY from deterministic structural outputs (e.g., target_howto routes, lockfiles deps, schema extract output, enforcement extractor output). Do NOT derive structural buckets from claims or file-index pattern matching. If a source doesn’t exist, leave bucket empty.
(2) In rendered reports, rename metrics explicitly: DCI_v1_claim_visibility, RCI_reporting_completeness, and show DCI_v2_structural_visibility (not implemented)—no generic “DCI v1.”
(3) Add optional deterministic “upgrade rules” for unknowns ONLY when exact infra/config artifacts are present (terraform/helm/k8s) with snippet hashes; otherwise UNKNOWN. No keyword matching.
Then paste artifacts: git diff --stat, diffs for verify_policy/adapter/render/diff/CLI, first 120 lines of evidence_pack, claims excerpt, and first 80 lines of DIFF_REPORT.

Once those are satisfied, Wave 1 is legitimately “audit-grade” and you can tag v0.1.0-wave1.

If you want, after this gate clears, I’ll give you the exact release notes and the one-page product language that aligns with the new metric semantics (so you don’t accidentally oversell DCI).