You just pasted a *narrative* that claims it’s already implemented and verified — but nothing in the terminal output you provided actually shows those diffs exist in the repo yet. So here are **exact Replit Agent / Copilot instructions** to implement the two improvements **for real**, with concrete code to drop in.

---

# Replit Agent / Copilot: Fix Pack (Double-finalization guard + Dev-only reset endpoint)

## Goal

1. Prevent races between **timeout**, **spawn error**, and **close** handlers (“double finalization”).
2. Add a **dev-only** endpoint `POST /api/admin/reset-analyzer` that:

   * deletes **projects** + **analyses**
   * wipes `out/`
   * returns `{ ok: true }`
   * returns **403** if `NODE_ENV === "production"`

---

## 1) Patch `runAnalysis()` with a single-finisher guard

### Files

* `server/routes.ts`

### Instructions

Inside `runAnalysis()`:

1. Add these helper functions/flags near the top of the function **right after** you set status to `"analyzing"`:

```ts
let finished = false;

const finishOnce = async (status: "completed" | "failed", msg?: string) => {
  if (finished) return;
  finished = true;

  if (msg) {
    if (status === "failed") console.error(msg);
    else console.log(msg);
  }

  await storage.updateProjectStatus(projectId, status);
};
```

2. Replace every direct `await storage.updateProjectStatus(projectId, "failed")` and `"completed"` inside timeout/error/close with `await finishOnce("failed", ...)` and `await finishOnce("completed", ...)`.

3. Ensure timeout clears itself and doesn’t race:

Replace your timeout block with:

```ts
const timeout = setTimeout(() => {
  if (finished) return;
  console.error(`[Analyzer ${projectId}] Timeout after 10 minutes — killing`);
  pythonProcess.kill("SIGKILL");
  void finishOnce("failed");
}, 10 * 60 * 1000);
```

4. In `pythonProcess.on("error", ...)`:

```ts
pythonProcess.on("error", (err) => {
  clearTimeout(timeout);
  if (finished) return;
  console.error(`[Analyzer ${projectId}] Spawn error:`, err);
  void finishOnce("failed");
});
```

5. In `pythonProcess.on("close", ...)`:

* First line inside handler:

```ts
pythonProcess.on("close", async (code) => {
  clearTimeout(timeout);
  if (finished) return; // in case timeout/error already finalized
```

* Then, on success path, DO NOT separately call update status; use `finishOnce("completed")`.
* On any failure path, use `finishOnce("failed")`.

6. Important: if you early-return due to missing required artifacts inside code==0, call `finishOnce("failed")` before returning.

---

## 2) Add storage reset method

### Files

* `server/storage.ts` (or wherever `storage` is implemented)

### Instructions

Add a new method on the storage interface + implementation:

**Interface:**

```ts
resetAnalyzerLogbook(): Promise<void>;
```

**Implementation (choose ONE based on your DB):**

### If SQLite / Drizzle:

Implement with deletes in FK-safe order:

```ts
async resetAnalyzerLogbook(): Promise<void> {
  // order matters if analyses references projects
  await this.db.delete(analyses);
  await this.db.delete(projects);
}
```

### If Postgres / SQL:

Use TRUNCATE with identity reset:

```ts
async resetAnalyzerLogbook(): Promise<void> {
  await this.pool.query(`TRUNCATE TABLE analyses RESTART IDENTITY CASCADE;`);
  await this.pool.query(`TRUNCATE TABLE projects RESTART IDENTITY CASCADE;`);
}
```

If you’re not sure which one you’re on, search `server/` for:

* `drizzle` / `sqlite` / `better-sqlite3`
* `pg` / `Pool` / `postgres`

---

## 3) Add dev-only reset endpoint

### Files

* `server/routes.ts`

### Instructions

Inside `registerRoutes()` add this route near your other routes (e.g. after `/health`), **before** `return httpServer;`:

```ts
app.post("/api/admin/reset-analyzer", async (_req, res) => {
  if (process.env.NODE_ENV === "production") {
    return res.status(403).json({ ok: false, message: "Forbidden in production" });
  }

  try {
    // reset DB
    await storage.resetAnalyzerLogbook();

    // wipe out dir
    const outDir = path.resolve(process.cwd(), "out");
    await fs.rm(outDir, { recursive: true, force: true });
    await fs.mkdir(outDir, { recursive: true });

    res.json({ ok: true });
  } catch (err) {
    console.error("reset-analyzer failed:", err);
    res.status(500).json({ ok: false, message: "reset failed" });
  }
});
```

**Make sure** `path` and `fs` are already imported at top (they are in your current file).

---

## 4) Verification commands (Agent must run these)

1. Confirm route exists:

```bash
grep -n "reset-analyzer" -n server/routes.ts
```

2. Trigger reset:

```bash
curl -s -X POST http://localhost:5000/api/admin/reset-analyzer | cat
echo
```

3. Confirm projects empty:

```bash
curl -s http://localhost:5000/api/projects | cat
echo
```

4. Confirm out/ wiped:

```bash
ls -la out | sed -n '1,50p'
```

5. Confirm double-finalization guard works (simulate missing python):

```bash
mv .pythonlibs/bin/python3 .pythonlibs/bin/python3.BAK
curl -s -X POST http://localhost:5000/api/projects/analyze-replit | cat
echo
sleep 1
curl -s http://localhost:5000/api/projects | head -c 300; echo
mv .pythonlibs/bin/python3.BAK .pythonlibs/bin/python3
```

Expected: the new project should go to `failed` **once**, and logs should not show multiple status flips.

---

# One more thing (you’ll thank yourself)

Add an env gate so this endpoint can’t be called accidentally even in dev:

```ts
if (process.env.ENABLE_ADMIN_RESET !== "true") {
  return res.status(403).json({ ok: false, message: "Admin reset disabled" });
}
```

Then run server with `ENABLE_ADMIN_RESET=true`.

---

If you paste your `server/storage.ts` (or wherever `storage` is implemented), I’ll give you the **exact** reset method body matching your real DB layer so Copilot doesn’t guess wrong.
