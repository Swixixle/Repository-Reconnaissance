Below are **strict, comprehensive, copy-paste instructions** you can give a Replit Agent (or Copilot) to fix the PTA “How To” problem by **replacing the current How To tab with an Operator Dashboard**, and tightening the contract so PTA never generates “garbage steps” again.

I’m going to assume your repo has:

* a **frontend** that renders the tabs (Dossier / Claim Verification / How To)
* a **backend/analyzer** that emits `target_howto.json`, `claims.json`, etc.

If names differ, the agent should follow the intent + search strings.

---

## 0) Prime Directive (Non-Negotiable Rules)

**Agent must obey these rules when generating any “How to run / install / deploy” content:**

1. **No invented steps.**
   Any instruction step MUST be backed by evidence objects (`file:line` + snippet hash). If not evidenced, it must be emitted as `UNKNOWN` with a question prompt.

2. **Separate “EVIDENCED” vs “INFERRED” vs “UNKNOWN”.**

   * *EVIDENCED*: has at least one evidence citation
   * *INFERRED*: derived from evidence but not explicit (e.g., lockfile suggests package manager) — must label inference and cite evidence for the inference inputs
   * *UNKNOWN*: not determinable from static artifacts

3. **Never claim runtime correctness.**
   The UI must show your existing disclaimer: VERIFIED ≠ true at runtime.

4. **The dashboard is the default view.**
   The user should not be forced into a “How To” narrative tab.

---

## 1) Replace the “How To” Tab with **Operator Dashboard**

### 1.1 Frontend: rename/remove “How To”

**Task**

* Find the tab/nav definition and replace:

  * “How To” → “Dashboard”
* Ensure routes/IDs match.

**Search**

* `How To`
* `howto`
* `target_howto`
* `tabs =`
* `Dossier`
* `Claim Verification`

**Acceptance**

* UI shows tabs: **Dossier | Verification | Dashboard**
* No other “How To” label appears.

---

## 2) Dashboard Layout (Exact Sections)

Implement a single dashboard page with these sections in order:

### 2.1 Top: “Act Now” cards (3 cards)

**Card A: Run / Boot**

* Shows:

  * Detected install command(s)
  * Detected dev run command(s)
  * Detected prod run command(s)
  * Ports (if evidenced)
* Must show each command with evidence chips.

**Card B: Integrate**

* Shows:

  * API base path
  * endpoints list (top 10)
  * auth hints (if evidenced)
  * required env vars list (names only)
* Each item must link to evidence.

**Card C: Deploy**

* Shows:

  * Dockerfile / docker-compose present?
  * Procfile / Railway / Render / Vercel hints
  * Build/start commands
* Evidence required for each.

**Acceptance**

* Each card renders even if empty.
* Empty states show “UNKNOWN” with a short reason (“No Dockerfile detected.”)

---

### 2.2 System Snapshot table (Operational)

A table with rows:

* Runtime(s) (Node/Python) + version hints
* Entrypoints (server start files)
* Data store (Postgres/SQLite/etc)
* Migrations / schema tool (drizzle/alembic/etc)
* Secrets (env var names only)
* Observability (health endpoint, logging library)

**Acceptance**

* Every non-UNKNOWN cell has evidence.
* UNKNOWN cells include a one-line “could not determine from static artifacts”.

---

### 2.3 Readiness & Gaps

Implement a “Readiness” block:

* Boot Readiness
* Integration Readiness
* Deployment Readiness
* Observability Readiness

Each shows:

* score 0–100
* 3 bullets: what’s evidenced, what’s missing, biggest blocker

Then show a **Ranked Gaps list** (top 10):

* Each gap is actionable and evidence-supported (or explicitly says no evidence found)

**Acceptance**

* Scoring is deterministic and based only on presence/absence of required components.
* Do not use LLM to compute the score.

---

### 2.4 Runbooks (Generated Recipes)

Add 4 expandable panels:

* Local Dev Runbook
* Production Runbook
* Integration Runbook
* Troubleshooting Runbook

**Rule:** these runbooks are assembled from `target_howto.json` but must strictly enforce:

* Each step has: `status` (EVIDENCED / INFERRED / UNKNOWN)
* Each step has: `command` or `action`
* Each step has: `evidence[]` (empty only if UNKNOWN, but then must have `unknown_reason`)

**Acceptance**

* If `install_steps` in JSON are weak, panel shows mostly UNKNOWN rather than invented instructions.

---

## 3) Fix the Data Contract: Replace `target_howto.json` with `operate.json` (or keep file but change schema)

Right now `target_howto.json` reads like a narrative operator manual. That invites hallucinated sequences.

**Do this instead:**

* Keep `target_howto.json` for backward compatibility, but generate a new file:

  * `operate.json` (preferred) or `dashboard.json`

### 3.1 New file schema (STRICT)

Create `operate.json` with this exact shape:

```json
{
  "tool_version": "pta-<semver>",
  "mode": "replit|local|github",
  "generated_at": "ISO-8601",
  "boot": {
    "install": [ { "status": "EVIDENCED|INFERRED|UNKNOWN", "command": "...", "evidence": [], "unknown_reason": "" } ],
    "dev":     [ { ... } ],
    "prod":    [ { ... } ],
    "ports":   [ { "status": "...", "value": "5000", "evidence": [] } ]
  },
  "integrate": {
    "base_path": { "status": "...", "value": "/api", "evidence": [] },
    "endpoints": [ { "method": "GET", "path": "/api/verify", "status": "...", "evidence": [] } ],
    "auth":      [ { "status": "...", "value": "bearer token", "evidence": [] } ],
    "env_vars":  [ { "name": "DATABASE_URL", "status": "...", "evidence": [] } ]
  },
  "deploy": {
    "docker": { "status": "...", "dockerfile": true, "compose": false, "evidence": [] },
    "platform_hints": [ { "status": "...", "value": "replit", "evidence": [] } ]
  },
  "snapshot": {
    "runtime": [ { "status": "...", "value": "python 3.11", "evidence": [] } ],
    "entrypoints": [ { "status": "...", "value": "server/index.ts", "evidence": [] } ],
    "datastore": [ { "status": "...", "value": "postgres", "evidence": [] } ],
    "migrations": [ { "status": "...", "value": "drizzle", "evidence": [] } ],
    "observability": [ { "status": "...", "value": "health endpoint", "evidence": [] } ]
  },
  "readiness": {
    "boot": { "score": 0, "reasons": [] },
    "integration": { "score": 0, "reasons": [] },
    "deployment": { "score": 0, "reasons": [] },
    "observability": { "score": 0, "reasons": [] }
  },
  "gaps": [
    { "rank": 1, "title": "No Dockerfile detected", "status": "EVIDENCED|UNKNOWN", "evidence": [], "action": "Add Dockerfile or document deploy method" }
  ],
  "runbooks": {
    "local_dev": [ { "step": 1, "status": "...", "action": "...", "command": "...", "evidence": [], "unknown_reason": "" } ],
    "production": [ ... ],
    "integration": [ ... ],
    "troubleshooting": [ ... ]
  }
}
```

**Acceptance**

* JSON schema validation exists for this new file.
* Frontend dashboard reads from `operate.json` if present; otherwise falls back to `target_howto.json`.

---

## 4) Analyzer: How to Build `operate.json` Deterministically

### 4.1 Deterministic extraction rules (no LLM)

Implement these extraction pipelines:

**Install commands:**

* If `package-lock.json` exists → infer `npm ci` (INFERRED)
* If `yarn.lock` exists → infer `yarn install` (INFERRED)
* If `pnpm-lock.yaml` exists → infer `pnpm i` (INFERRED)
* If `pyproject.toml` exists → infer `pip install -e .` ONLY if evidenced in README/setup config, otherwise UNKNOWN
* If `requirements.txt` exists → infer `pip install -r requirements.txt` (INFERRED)

**Run commands:**

* Extract `scripts` from `package.json` with evidence:

  * dev/build/start/test
* Extract Makefile targets similarly if present.
* Extract Replit `.replit` run command if present.

**Ports:**

* Detect `PORT` usage or hard-coded `listen(...)` values with evidence.
* If nothing found: UNKNOWN.

**Endpoints:**

* Identify Express/FastAPI/Flask routes with evidence (method + path).
* Cap to top 50.

**Env vars:**

* Extract env var names from:

  * `process.env.X`
  * `os.environ["X"]`
  * dotenv patterns
* Never values.

**Auth:**

* Only mark auth if explicit evidence exists (middleware named auth, bearer parsing, etc.)
* Otherwise UNKNOWN.

**Acceptance**

* In `--no-llm` mode, `operate.json` is still produced with deterministic content.

---

## 5) Fix the PTA README File You Pasted (Tighten + Update Output List)

Update the section titled “What It Does” and “Output Files” to include the new dashboard file and to demote “How To” into “Runbooks assembled from evidence”.

### 5.1 Exact README edits

**Do:**

* Add file row:

  * `operate.json` — Operator dashboard model (boot/integrate/deploy/snapshot/gaps/runbooks) built from evidence
* Change the description of `target_howto.json` to:

  * “Legacy: evidence-scoped run steps; may contain UNKNOWNs when not evidenced”

**Acceptance**

* README no longer implies PTA can generate a complete implementation guide for arbitrary systems.
* README explicitly states “runbooks are evidence-scoped; unknowns are expected.”

---

## 6) Tests (Mandatory)

Add tests that prevent regression into “garbage how-to”.

### 6.1 Unit tests

* If a runbook step has `status="EVIDENCED"` then `evidence.length >= 1`
* If `status="UNKNOWN"` then `unknown_reason` must be non-empty
* If `status="INFERRED"` then must have evidence supporting the inference inputs (e.g., lockfile existence)

### 6.2 Golden test fixture

* Use a known repo fixture to ensure:

  * install/dev/prod commands extract correctly
  * endpoints extracted
  * env vars extracted
  * readiness scores computed deterministically

**Acceptance**

* CI fails if the analyzer outputs an EVIDENCED step with no evidence.

---

## 7) “Stop the Bleeding” Hotfix (If You Want Immediate Improvement Without Full Refactor)

If you can’t implement the full dashboard immediately:

**Quick patch to `target_howto.json` generator:**

* Before emitting any “step”:

  * require evidence
  * else emit UNKNOWN
* Add `status` field per step.
* Update UI to display UNKNOWN instead of forcing narrative.

This alone will make the “How To” tab stop lying.

---

## 8) Final Acceptance Criteria (Definition of Done)

The work is done when:

1. The UI has **Dashboard** instead of **How To**.
2. `operate.json` exists and is displayed.
3. Every displayed instruction is either:

   * EVIDENCED with citations, or
   * clearly labeled INFERRED, or
   * UNKNOWN with a reason.
4. `--no-llm` still produces `operate.json`.
5. Tests enforce “no evidenced step without evidence.”

---

## Copy-paste instruction header you can give the agent

> Implement Operator Dashboard to replace PTA How To. Add deterministic `operate.json` contract and render it. No invented steps—every instruction must be evidence-backed or marked UNKNOWN. Update README to include `operate.json`. Add tests preventing evidence-less steps.

If you want, paste the **frontend file tree** (just the `src/` folder names) and I’ll rewrite the instructions with **exact filenames + exact code insertion points** (so the agent can’t miss).
