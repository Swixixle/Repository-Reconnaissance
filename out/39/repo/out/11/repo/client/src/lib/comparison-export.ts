import { ComparisonResult } from "./comparison";

// Hardening Helper
const safeStr = (str: string) => {
    // Escape pipes, backticks, etc.
    return str.replace(/\|/g, "\\|").replace(/`/g, "\\`");
};

export function generateComparisonMarkdown(result: ComparisonResult): string {
    const date = new Date().toISOString().split('T')[0];
    
    let md = `---
title: "Cross-Dossier Comparison: ${safeStr(result.packA.name)} vs ${safeStr(result.packB.name)}"
date: ${date}
packA: ${result.packA.id}
packB: ${result.packB.id}
fingerprint: ${result.fingerprint || "pending"}
overlapJaccard: ${result.overlapScore.toFixed(3)}
generatedBy: Lantern Protocol
---

# Cross-Dossier Comparison
**Date:** ${date}
**Comparison Fingerprint (SHA-256):** \`${result.fingerprint || "pending"}\`
**Generated By:** Lantern Protocol

## Scope
* **Dossier A:** ${safeStr(result.packA.name)} (\`${result.packA.id}\`)
* **Dossier B:** ${safeStr(result.packB.name)} (\`${result.packB.id}\`)

> **Interpretation Limits & Disclaimer (Comparison)**
> * **Probabilistic Matching:** Shared entities are matched by ID (exact) or Name (fuzzy). Name matches should be manually verified.
> * **Structure vs. Intent:** Alignment in structural role (e.g., "Top Funder") does not imply coordination or shared intent between the two contexts.
> * **Insufficient Data:** Structural alignment is only calculated if both dossiers meet minimum evidence density thresholds.

## 01. Entity Overlap
* **Shared Entities:** ${result.sharedEntities.length}
* **Jaccard Overlap Index:** ${(result.overlapScore * 100).toFixed(1)}%

### Shared Entities List
| Entity Name | Match Type |
|-------------|------------|
`;

    if (result.sharedEntities.length === 0) {
        md += `| *No shared entities found* | - |\n`;
    } else {
        result.sharedEntities.forEach(match => {
            md += `| ${safeStr(match.name)} | ${match.confidence.replace("_", " ")} |\n`;
        });
    }
    md += `\n`;

    // --- Structural Alignment ---
    md += `## 02. Structural Alignment\n\n`;

    // Funding
    md += `### Common Top Funders\n`;
    if (result.heuristics.funding.statusA === "insufficient" || result.heuristics.funding.statusB === "insufficient") {
        md += `> **Analysis Unavailable:** One or both dossiers have insufficient funding data to support comparison.\n\n`;
    } else if (result.commonFunders.length === 0) {
        md += `*No common top funders found.*\n\n`;
    } else {
        md += `| Entity | Rank in A | Rank in B |\n`;
        md += `|--------|-----------|-----------|\n`;
        result.commonFunders.forEach(c => {
            md += `| ${safeStr(c.name)} | #${c.rankA} | #${c.rankB} |\n`;
        });
        md += `\n`;
    }

    // Influence
    md += `### Common Influence Hubs\n`;
    if (result.heuristics.influence.statusA === "insufficient" || result.heuristics.influence.statusB === "insufficient") {
        md += `> **Analysis Unavailable:** One or both dossiers have insufficient structural data to support comparison.\n\n`;
    } else if (result.commonHubs.length === 0) {
        md += `*No common influence hubs found.*\n\n`;
    } else {
        md += `| Entity | Rank in A | Rank in B |\n`;
        md += `|--------|-----------|-----------|\n`;
        result.commonHubs.forEach(c => {
            md += `| ${safeStr(c.name)} | #${c.rankA} | #${c.rankB} |\n`;
        });
        md += `\n`;
    }

    // Enforcement
    md += `### Common Enforcers\n`;
    if (result.heuristics.enforcement.statusA === "insufficient" || result.heuristics.enforcement.statusB === "insufficient") {
        md += `> **Analysis Unavailable:** One or both dossiers have insufficient enforcement data to support comparison.\n\n`;
    } else if (result.commonEnforcers.length === 0) {
        md += `*No common enforcers found.*\n\n`;
    } else {
        md += `| Entity | Rank in A | Rank in B |\n`;
        md += `|--------|-----------|-----------|\n`;
        result.commonEnforcers.forEach(c => {
            md += `| ${safeStr(c.name)} | #${c.rankA} | #${c.rankB} |\n`;
        });
        md += `\n`;
    }

    return md;
}
