
--- FILE: attached_assets/Pasted-Got-it-Copilot-said-it-did-it-but-you-need-reproducible_1771067676312.txt ---
L1: Got it. Copilot “said it did it,” but you need **reproducible, mechanical steps** that a Replit agent can execute (and that you can verify) — not narrative.
L2: 
L3: Below is a **single, concrete instruction block** you can paste to the Replit agent. It assumes your current reality:
L4: 
L5: * CLI currently lives at: `server/analyzer/analyzer_cli.py` (NOT under `src/`)
L6: * Your python package code lives at: `server/analyzer/src/`
L7: * Some imports are `from core...` and break when importing as a package
L8: * You want: **`pta` console command + `python -m ...` + direct file execution** all working
L9: 
L10: ---
L11: 
L12: ## Paste this to Replit agent (verbatim)
L13: 
L14: ### Objective
L15: 
L16: Make PTA installable + runnable in 3 ways:
L17: 
L18: 1. `pta --help` (console script)
L19: 2. `python -m server.analyzer.src.analyzer_cli --help` (module invocation)
L20: 3. `python server/analyzer/analyzer_cli.py --help` (direct file)
L21: 
L22: Also add `scripts/smoke_test.sh`, `examples/out/*.sample.json`, and an operator-grade `README.md`.
L23: 
L24: ### Rules
L25: 
L26: * No “try/except import hacks” unless absolutely necessary.
L27: * Prefer **proper packages + relative imports**.
L28: * Do not change analyzer behavior. Only packaging/entrypoints/docs.
L29: 
L30: ---
L31: 
L32: ### Step 1 — Confirm package init files exist
L33: 
L34: Create these files if missing (empty is fine):
L35: 
L36: * `server/analyzer/__init__.py`
L37: * `server/analyzer/src/__init__.py`
L38: * `server/analyzer/src/core/__init__.py`
L39: 
L40: Command:
L41: 
L42: ```bash
L43: mkdir -p server/analyzer/src/core
L44: touch server/analyzer/__init__.py server/analyzer/src/__init__.py server/analyzer/src/core/__init__.py
L45: ```
L46: 
L47: ---
L48: 
L49: ### Step 2 — Fix `core` import break (the reason you saw ModuleNotFoundError)
L50: 
L51: Right now `server/analyzer/src/analyzer.py` imports `core.acquire` etc, which only works when `src/` is manually on PYTHONPATH.
L52: 
L53: **Replace all `from core...` and `import core...` inside `server/analyzer/src/**` with relative imports.**
L54: 
L55: Example conversions:
L56: 
L57: * `from core.acquire import ...` → `from .core.acquire import ...`
L58: * `from core.evidence import ...` → `from .core.evidence import ...`
L59: * `import core.replit_profile as rp` → `from .core import replit_profile as rp`
L60: 
L61: Command to find offenders:
L62: 
L63: ```bash
L64: grep -RIn --exclude-dir=node_modules --exclude-dir=.git "from core\.|import core\." server/analyzer/src
L65: ```
L66: 
L67: Then edit each file and fix imports.
L68: 
L69: ---
L70: 
L71: ### Step 3 — Make a single canonical CLI module in `src/`
L72: 
L73: Create: `server/analyzer/src/analyzer_cli.py`
L74: 
L75: This file should be the *only* “real” CLI implementation.
L76: 
L77: Then update the root CLI `server/analyzer/analyzer_cli.py` to become a **thin wrapper** that imports and runs the src CLI.
L78: 
L79: #### 3A) `server/analyzer/src/analyzer_cli.py`
L80: 
L81: * Must define Typer app: `app = typer.Typer(...)`
L82: * Must end with:
L83: 
L84: ```python
L85: if __name__ == "__main__":
L86:     app()
L87: ```
L88: 
L89: * Must import Analyzer using package-relative import:
L90: 
L91: ```python
L92: from .analyzer import Analyzer
L93: ```
L94: 
L95: #### 3B) wrapper file `server/analyzer/analyzer_cli.py`
L96: 
L97: Replace contents with:
L98: 
L99: ```python
L100: from server.analyzer.src.analyzer_cli import app
L101: 
L102: if __name__ == "__main__":
L103:     app()
L104: ```
L105: 
L106: No sys.path hacks. No environment assumptions.
L107: 
L108: ---
L109: 
L110: ### Step 4 — Add module entrypoint (optional but clean)
L111: 
L112: Create `server/analyzer/src/__main__.py`:
L113: 
L114: ```python
L115: from .analyzer_cli import app
L116: 
L117: if __name__ == "__main__":
L118:     app()
L119: ```
L120: 
L121: This allows:
L122: 
L123: ```bash
L124: python -m server.analyzer.src --help
L125: ```
L126: 
L127: ---
L128: 
L129: ### Step 5 — Configure `pyproject.toml` for console script
L130: 
L131: In repo root `pyproject.toml`, ensure:
L132: 
L133: * project name/version exist
L134: * includes packages so `server` is importable
L135: * console script:
L136: 
L137: ```toml
L138: [project.scripts]
L139: pta = "server.analyzer.src.analyzer_cli:app"
L140: ```
L141: 
L142: If you’re using setuptools, ensure package discovery includes `server`. If using hatch/poetry, set packages accordingly.
L143: 
L144: Then test editable install:
L145: 
L146: ```bash
L147: python -m pip install -e .
L148: pta --help
L149: ```
L150: 
L151: ---
L152: 
L153: ### Step 6 — Smoke test script
L154: 
L155: Create `scripts/smoke_test.sh`:
L156: 
L157: Requirements:
L158: 
L159: * `set -euo pipefail`
L160: * verifies all 3 invocation methods
L161: * runs deterministic analysis and checks output files exist
L162: 
L163: Minimum script:
L164: 
L165: ```bash
L166: #!/usr/bin/env bash
L167: set -euo pipefail
L168: 
L169: TMP="$(mktemp -d)"
L170: OUT="$TMP/out"
L171: 
L172: echo "1) pta --help"
L173: pta --help >/dev/null
L174: 
L175: echo "2) python -m server.analyzer.src --help"
L176: python -m server.analyzer.src --help >/dev/null
L177: 
L178: echo "3) python server/analyzer/analyzer_cli.py --help"
L179: python server/analyzer/analyzer_cli.py --help >/dev/null
L180: 
L181: echo "4) deterministic run"
L182: pta analyze --replit -o "$OUT" --no-llm
L183: 
L184: test -f "$OUT/target_howto.json"
L185: test -f "$OUT/coverage.json"
L186: 
L187: echo "PASS"
L188: ```
L189: 
L190: Then:
L191: 
L192: ```bash
L193: chmod +x scripts/smoke_test.sh
L194: bash scripts/smoke_test.sh
L195: ```
L196: 
L197: ---
L198: 
L199: ### Step 7 — Examples snapshot
L200: 
L201: Create:
L202: 
L203: * `examples/out/target_howto.sample.json`
L204: * `examples/out/coverage.sample.json`
L205: 
L206: Generate fresh:
L207: 
L208: ```bash
L209: rm -rf /tmp/pta_out_sample
L210: pta analyze --replit -o /tmp/pta_out_sample --no-llm
L211: mkdir -p examples/out
L212: cp /tmp/pta_out_sample/target_howto.json examples/out/target_howto.sample.json
L213: cp /tmp/pta_out_sample/coverage.json examples/out/coverage.sample.json
L214: ```
L215: 
L216: Commit these.
L217: 
L218: ---
L219: 
L220: ### Step 8 — README.md (operator-grade)
L221: 
L222: Write README sections:
L223: 
L224: * What PTA does
L225: * Install (`pip install -e .`)
L226: * Run modes:
L227: 
L228:   * GitHub URL
L229:   * local path
L230:   * `--replit`
L231: * Deterministic mode: `--no-llm`
L232: * Outputs (target_howto.json, coverage.json, etc)
L233: * Evidence model (snippet_hash, line_start/line_end, file_exists)
L234: * Troubleshooting:
L235: 
L236:   * `ModuleNotFoundError: core`
L237:   * missing env vars (`DATABASE_URL`, etc)
L238:   * port conflicts
L239: 
L240: ---
L241: 
L242: ### Step 9 — Final verification commands (must paste results)
L243: 
L244: Run and paste outputs:
L245: 
L246: ```bash
L247: python -m pip install -e .
L248: pta --help | head
L249: python -m server.analyzer.src --help | head
L250: python server/analyzer/analyzer_cli.py --help | head
L251: bash scripts/smoke_test.sh
L252: ```
L253: 
L254: If all pass, repo is “functional and shippable”.
L255: 
L256: ---
L257: 
L258: ## Why Copilot “said it worked” but you still saw failures
L259: 
L260: * Your first attempt imported `server.analyzer.src.analyzer` directly, which triggered `from core.acquire...` and failed because `core` wasn’t a real package on sys.path.
L261: * Your later `PYTHONPATH=server/analyzer/src python ...` worked because you *manually* made `core` importable. That’s not shippable.
L262: * The fix is what you already proved in the live dump: **relative imports + real packaging**.
L263: 
L264: ---
L265: 
L266: If you want to “wrap this up” even harder: after the Replit agent runs those steps, have it paste **only** the output of Step 9. That’s your proof that the setup is actually functional (not “agent narrative”).

--- FILE: attached_assets/Pasted-This-is-a-fascinating-artifact-You-ve-shared-what-appea_1771147259856.txt ---
L1: This is a fascinating artifact. You've shared what appears to be the **PTA Operator Dashboard UI** showing the analysis results for the PTA system itself. This is self-referential in the best possible way—the system analyzing itself.
L2: 
L3: Let me interpret this dashboard view:
L4: 
L5: ## What This Dashboard Reveals
L6: 
L7: ### 1. **The UI/UX Philosophy**
L8: The dashboard is designed for **operational decision-making**, not just passive reading:
L9: - **Progress bars** (Boot 100%, Integration 100%, Deployment 75%, Observability 0%) give instant at-a-glance status
L10: - **Operational Gaps** are surfaced prominently with risk ratings (MEDIUM/LOW)
L11: - **Runbooks** are treated as first-class artifacts—the system literally generates operational documentation
L12: - **Claims Verification** is a separate tab, suggesting the tool can validate its own findings
L13: 
L14: ### 2. **The Self-Analysis is Honest**
L15: The dashboard shows PTA's own weaknesses transparently:
L16: - **Deployment at 75%** - Missing Docker/production deployment docs
L17: - **Observability at 0%** - No health endpoints or logging setup
L18: - **Operational Gaps** explicitly call out what's missing
L19: 
L20: This is either extreme intellectual honesty or a subtle flex—"our tool is so good it can identify its own shortcomings."
L21: 
L22: ### 3. **Evidence Density is High**
L23: Every item has a status:
L24: - **EVIDENCED** - Found in code/config with line numbers
L25: - **INFERRED** - Reasonable deduction (e.g., "npm ci" because package-lock.json exists)
L26: - **UNKNOWN** - Can't determine from static analysis
L27: 
L28: This creates a **trust gradient**—users know exactly how confident to be in each finding.
L29: 
L30: ## Key Technical Observations
L31: 
L32: ### Architecture Confirmation
L33: The dashboard validates the polyglot nature:
L34: - Node.js dependencies (`npm ci`)
L35: - Python dependencies (`pip install -e .`)
L36: - Dual dev commands (one in package.json, one in .replit)
L37: - Multiple integration domains (audio, chat, image generation)
L38: 
L39: ### Security Surface
L40: The environment variables section is revealing:
L41: - `AI_INTEGRATIONS_OPENAI_API_KEY` - LLM integration
L42: - `DATABASE_URL` - PostgreSQL access
L43: - `REPL_ID` - Replit-specific identifier
L44: 
L45: Notably missing from the dashboard display (but present in the dossier) is the `API_KEY` for endpoint authentication—interesting that the dashboard doesn't surface that as a requirement.
L46: 
L47: ### The 0% Observability Gap
L48: This is the most striking finding. A system designed to analyze other systems **has no observability of its own**:
L49: - No health endpoints detected (despite `/api/health` being in the dossier—contradiction?)
L50: - No log storage/viewing commands
L51: - No metrics export
L52: 
L53: This suggests PTA is built for **ephemeral analysis** rather than **long-running service operation**.
L54: 
L55: ## Questions This Raises
L56: 
L57: 1. **Is the dashboard interactive?** Can operators click through to see the evidence? The "EVIDENCED" tags suggest drill-down capability.
L58: 
L59: 2. **How are unknowns resolved?** If I added a Dockerfile, would the dashboard automatically update to 100%?
L60: 
L61: 3. **What's in the "Claims Verification" tab?** That might show the LLM-powered analysis vs. deterministic extraction.
L62: 
L63: 4. **Why the duplicate API endpoints?** Both `/api/conversations` appear under audio AND chat routes—separate modules or duplication?
L64: 
L65: ## The Meta-Lesson
L66: 
L67: This dashboard embodies a principle I rarely see executed well: **transparency about your own transparency tools**.
L68: 
L69: By showing PTA's own gaps (0% observability) in the same interface it uses to show other systems' gaps, the creators are making a statement: "We hold ourselves to the same standard we hold you."
L70: 
L71: This is either:
L72: - A demonstration of the tool's capabilities ("look, it even finds our flaws")
L73: - A roadmap for the maintainers ("we should fix our own observability")
L74: - Both
L75: 
L76: ## If I Were Evaluating This for My Team
L77: 
L78: **Would I use PTA?** Absolutely, but with caveats:
L79: - **For onboarding**: Generate dossiers for every service, new hires get instant system understanding
L80: - **For security reviews**: Run PTA before pen tests to ensure documentation matches reality
L81: - **For compliance**: Use the evidence index as audit preparation
L82: 
L83: **Would I run PTA in production as a service?** Not yet—the 0% observability is a dealbreaker for a service I need to keep running. But as a CLI tool run on demand? Perfect.
L84: 
L85: The dashboard is a glimpse into a future where **documentation is executable** and **operational intelligence is automated**. I'm impressed and slightly intimidated by the recursion.

--- FILE: server/ci-worker.ts ---
L1: import { storage } from "./storage";
L2: import { spawn } from "child_process";
L3: import path from "path";
L4: import fs from "fs/promises";
L5: import { existsSync, mkdirSync } from "fs";
L6: 
L7: const CI_OUT_BASE = path.resolve(process.cwd(), "out", "ci");
L8: 
L9: export async function processOneJob(): Promise<{ processed: boolean; runId?: string; status?: string }> {
L10:   const leased = await storage.leaseNextJob();
L11:   if (!leased) return { processed: false };
L12: 
L13:   const { job, run } = leased;
L14:   console.log(`[CI Worker] Leased job=${job.id} run=${run.id} repo=${run.repoOwner}/${run.repoName} sha=${run.commitSha}`);
L15: 
L16:   const outDir = path.join(CI_OUT_BASE, run.id);
L17:   mkdirSync(outDir, { recursive: true });
L18: 
L19:   let tmpDir: string | null = null;
L20:   try {
L21:     tmpDir = await fetchRepo(run.repoOwner, run.repoName, run.commitSha);
L22:     const result = await runAnalyzerOnDir(tmpDir, outDir, run.id);
L23: 
L24:     if (result.success) {
L25:       await storage.updateCiRun(run.id, {
L26:         status: "SUCCEEDED",
L27:         finishedAt: new Date(),
L28:         outDir: `out/ci/${run.id}`,
L29:         summaryJson: result.summary || null,
L30:       });
L31:       await storage.completeJob(job.id, "DONE");
L32:       console.log(`[CI Worker] Run ${run.id} SUCCEEDED`);
L33:       return { processed: true, runId: run.id, status: "SUCCEEDED" };
L34:     } else {
L35:       await storage.updateCiRun(run.id, {
L36:         status: "FAILED",
L37:         finishedAt: new Date(),
L38:         error: result.error || "unknown_error",
L39:         outDir: `out/ci/${run.id}`,
L40:       });
L41:       await storage.completeJob(job.id, "DONE", result.error);
L42:       console.log(`[CI Worker] Run ${run.id} FAILED: ${result.error}`);
L43:       return { processed: true, runId: run.id, status: "FAILED" };
L44:     }
L45:   } catch (err: any) {
L46:     const errMsg = String(err?.message || err);
L47:     console.error(`[CI Worker] Job ${job.id} exception:`, errMsg);
L48: 
L49:     if (job.attempts >= 3) {
L50:       await storage.updateCiRun(run.id, {
L51:         status: "FAILED",
L52:         finishedAt: new Date(),
L53:         error: `max_attempts: ${errMsg}`,
L54:       });
L55:       await storage.completeJob(job.id, "DEAD", errMsg);
L56:     } else {
L57:       await storage.completeJob(job.id, "DEAD", errMsg);
L58:     }
L59:     return { processed: true, runId: run.id, status: "FAILED" };
L60:   } finally {
L61:     if (tmpDir) {
L62:       await fs.rm(tmpDir, { recursive: true, force: true }).catch(() => {});
L63:     }
L64:   }
L65: }
L66: 
L67: async function fetchRepo(owner: string, repo: string, sha: string): Promise<string> {
L68:   const tmpBase = path.resolve(process.env.CI_TMP_DIR || "/tmp/ci");
L69:   const tmpDir = path.join(tmpBase, `${owner}-${repo}-${sha}-${Date.now()}`);
L70:   await fs.mkdir(tmpDir, { recursive: true });
L71: 
L72:   const repoUrl = `https://github.com/${owner}/${repo}.git`;
L73:   const token = process.env.GITHUB_TOKEN;
L74: 
L75:   let cloneUrl = repoUrl;
L76:   if (token) {
L77:     cloneUrl = `https://x-access-token:${token}@github.com/${owner}/${repo}.git`;
L78:   }
L79: 
L80:   await execCommand("git", ["clone", "--depth", "1", cloneUrl, tmpDir]);
L81: 
L82:   await execCommand("git", ["-C", tmpDir, "fetch", "--depth", "1", "origin", sha]);
L83:   await execCommand("git", ["-C", tmpDir, "checkout", sha]);
L84: 
L85:   return tmpDir;
L86: }
L87: 
L88: function execCommand(cmd: string, args: string[]): Promise<string> {
L89:   return new Promise((resolve, reject) => {
L90:     const proc = spawn(cmd, args, { cwd: process.cwd() });
L91:     let stdout = "";
L92:     let stderr = "";
L93:     proc.stdout.on("data", (d) => { stdout += d.toString(); });
L94:     proc.stderr.on("data", (d) => { stderr += d.toString(); });
L95:     proc.on("error", reject);
L96:     proc.on("close", (code) => {
L97:       if (code === 0) resolve(stdout);
L98:       else reject(new Error(`${cmd} exited with code ${code}: ${stderr.slice(-500)}`));
L99:     });
L100:   });
L101: }
L102: 
L103: async function runAnalyzerOnDir(
L104:   repoDir: string,
L105:   outDir: string,
L106:   runId: string
L107: ): Promise<{ success: boolean; error?: string; summary?: any }> {
L108:   const pythonBin = path.join(process.cwd(), ".pythonlibs/bin/python3");
L109:   if (!existsSync(pythonBin)) {
L110:     return { success: false, error: "python_not_found" };
L111:   }
L112: 
L113:   const args = ["-m", "server.analyzer.analyzer_cli", "analyze", repoDir, "--output-dir", outDir];
L114:   console.log(`[CI Worker] Running analyzer: ${pythonBin} ${args.join(" ")}`);
L115: 
L116:   return new Promise((resolve) => {
L117:     let stderr = "";
L118:     const proc = spawn(pythonBin, args, {
L119:       cwd: process.cwd(),
L120:       env: { ...process.env },
L121:     });
L122: 
L123:     const timeout = setTimeout(() => {
L124:       proc.kill("SIGKILL");
L125:       resolve({ success: false, error: "timeout_10m" });
L126:     }, Number(process.env.ANALYZER_TIMEOUT_MS) || 10 * 60 * 1000);
L127: 
L128:     proc.stdout.on("data", (d) => {
L129:       console.log(`[CI Analyzer ${runId}]: ${d}`);
L130:     });
L131:     proc.stderr.on("data", (d) => {
L132:       stderr += d.toString();
L133:       console.error(`[CI Analyzer ${runId} ERR]: ${d}`);
L134:     });
L135:     proc.on("error", (err) => {
L136:       clearTimeout(timeout);
L137:       resolve({ success: false, error: `spawn_error: ${err}` });
L138:     });
L139:     proc.on("close", async (code) => {
L140:       clearTimeout(timeout);
L141:       if (code !== 0) {
L142:         resolve({ success: false, error: `exit_code_${code}: ${stderr.slice(-300)}` });
L143:         return;
L144:       }
L145: 
L146:       try {
L147:         let summary: any = null;
L148:         const operatePath = path.join(outDir, "operate.json");
L149:         if (existsSync(operatePath)) {
L150:           const raw = await fs.readFile(operatePath, "utf-8");
L151:           const op = JSON.parse(raw);
L152:           summary = {
L153:             readiness: op.readiness_scores || null,
L154:             boot_commands: (op.boot_commands || []).length,
L155:             endpoints: (op.integration_points?.endpoints || []).length,
L156:             env_vars: (op.integration_points?.env_vars || []).length,
L157:             gaps: (op.operational_gaps || []).length,
L158:           };
L159:         }
L160:         resolve({ success: true, summary });
L161:       } catch {
L162:         resolve({ success: true, summary: null });
L163:       }
L164:     });
L165:   });
L166: }
L167: 
L168: let workerInterval: ReturnType<typeof setInterval> | null = null;
L169: 
L170: export function startWorkerLoop(intervalMs: number = 5000) {
L171:   if (workerInterval) return;
L172:   console.log(`[CI Worker] Starting background loop (every ${intervalMs}ms)`);
L173:   workerInterval = setInterval(async () => {
L174:     try {
L175:       await processOneJob();
L176:     } catch (err) {
L177:       console.error("[CI Worker] Loop error:", err);
L178:     }
L179:   }, intervalMs);
L180: }
L181: 
L182: export function stopWorkerLoop() {
L183:   if (workerInterval) {
L184:     clearInterval(workerInterval);
L185:     workerInterval = null;
L186:     console.log("[CI Worker] Stopped background loop");
L187:   }
L188: }

--- FILE: client/src/pages/ci-feed.tsx ---
L1: import { useState, useEffect } from "react";
L2: import { useQuery, useMutation } from "@tanstack/react-query";
L3: import { Layout } from "@/components/layout";
L4: import { Card } from "@/components/ui/card";
L5: import { Button } from "@/components/ui/button";
L6: import { Input } from "@/components/ui/input";
L7: import { Badge } from "@/components/ui/badge";
L8: import { queryClient, apiRequest } from "@/lib/queryClient";
L9: import { Link } from "wouter";
L10: import { formatDistanceToNow } from "date-fns";
L11: import {
L12:   GitBranch, GitCommit, Clock, Play,
L13:   CheckCircle2, XCircle, Loader2, RefreshCw,
L14:   Activity, ExternalLink,
L15: } from "lucide-react";
L16: import { motion } from "framer-motion";
L17: 
L18: interface CiRun {
L19:   id: string;
L20:   repoOwner: string;
L21:   repoName: string;
L22:   ref: string;
L23:   commitSha: string;
L24:   eventType: string;
L25:   status: string;
L26:   createdAt: string;
L27:   startedAt: string | null;
L28:   finishedAt: string | null;
L29:   error: string | null;
L30:   outDir: string | null;
L31:   summaryJson: any;
L32: }
L33: 
L34: function CiStatusBadge({ status }: { status: string }) {
L35:   const config: Record<string, { className: string; icon: React.ReactNode }> = {
L36:     QUEUED: {
L37:       className: "bg-yellow-500/10 text-yellow-500 border-yellow-500/20",
L38:       icon: <Clock className="w-3 h-3 mr-1" />,
L39:     },
L40:     RUNNING: {
L41:       className: "bg-blue-500/10 text-blue-500 border-blue-500/20 animate-pulse",
L42:       icon: <Loader2 className="w-3 h-3 mr-1 animate-spin" />,
L43:     },
L44:     SUCCEEDED: {
L45:       className: "bg-emerald-500/10 text-emerald-500 border-emerald-500/20",
L46:       icon: <CheckCircle2 className="w-3 h-3 mr-1" />,
L47:     },
L48:     FAILED: {
L49:       className: "bg-destructive/10 text-destructive border-destructive/20",
L50:       icon: <XCircle className="w-3 h-3 mr-1" />,
L51:     },
L52:   };
L53:   const c = config[status] || config.QUEUED;
L54:   return (
L55:     <Badge variant="outline" className={`no-default-hover-elevate no-default-active-elevate ${c.className} text-xs font-mono`} data-testid={`badge-ci-status-${status}`}>
L56:       {c.icon}
L57:       {status}
L58:     </Badge>
L59:   );
L60: }
L61: 
L62: export default function CiFeed() {
L63:   const [owner, setOwner] = useState("");
L64:   const [repo, setRepo] = useState("");
L65:   const [searchOwner, setSearchOwner] = useState("");
L66:   const [searchRepo, setSearchRepo] = useState("");
L67: 
L68:   const hasSearch = searchOwner.length > 0 && searchRepo.length > 0;
L69:   const hasActiveRuns = false;
L70: 
L71:   const { data, isLoading, refetch } = useQuery<{ ok: boolean; runs: CiRun[] }>({
L72:     queryKey: ["/api/ci/runs", `?owner=${searchOwner}&repo=${searchRepo}&limit=50`],
L73:     enabled: hasSearch,
L74:     refetchInterval: hasActiveRuns ? 3000 : 10000,
L75:   });
L76: 
L77:   const runs = data?.runs || [];
L78:   const anyActive = runs.some((r) => r.status === "QUEUED" || r.status === "RUNNING");
L79: 
L80:   useEffect(() => {
L81:     if (anyActive) {
L82:       const interval = setInterval(() => refetch(), 3000);
L83:       return () => clearInterval(interval);
L84:     }
L85:   }, [anyActive, refetch]);
L86: 
L87:   const [manualSha, setManualSha] = useState("");
L88:   const [manualRef, setManualRef] = useState("main");
L89: 
L90:   const enqueue = useMutation({
L91:     mutationFn: async () => {
L92:       const res = await apiRequest("POST", "/api/ci/enqueue", {
L93:         owner: searchOwner,
L94:         repo: searchRepo,
L95:         ref: manualRef,
L96:         commit_sha: manualSha,
L97:         event_type: "manual",
L98:       });
L99:       return res.json();
L100:     },
L101:     onSuccess: () => {
L102:       setManualSha("");
L103:       queryClient.invalidateQueries({ queryKey: ["/api/ci/runs"] });
L104:     },
L105:   });
L106: 
L107:   const handleSearch = (e: React.FormEvent) => {
L108:     e.preventDefault();
L109:     setSearchOwner(owner);
L110:     setSearchRepo(repo);
L111:   };
L112: 
L113:   const { data: health } = useQuery<{ ok: boolean; jobs: Record<string, number>; last_completed: any }>({
L114:     queryKey: ["/api/ci/health"],
L115:     refetchInterval: 15000,
L116:   });
L117: 
L118:   return (
L119:     <Layout>
L120:       <div className="max-w-5xl mx-auto">
L121:         <div className="flex flex-wrap items-end justify-between gap-4 mb-8">
L122:           <div>
L123:             <h1 className="text-3xl font-display font-bold text-foreground" data-testid="text-ci-feed-title">CI Feed</h1>
L124:             <p className="text-muted-foreground mt-1">Live static analysis runs triggered by GitHub events. Static analysis only (no runtime telemetry).</p>
L125:           </div>
L126:           {health?.ok && (
L127:             <div className="flex items-center gap-3 text-xs font-mono text-muted-foreground" data-testid="text-ci-health">
L128:               <Activity className="w-4 h-4 text-primary" />
L129:               {Object.entries(health.jobs).map(([s, c]) => (
L130:                 <span key={s}>{s}: {c}</span>
L131:               ))}
L132:             </div>
L133:           )}
L134:         </div>
L135: 
L136:         <Card className="p-4 mb-6">
L137:           <form onSubmit={handleSearch} className="flex flex-wrap gap-2 items-end">
L138:             <div className="flex-1 min-w-[120px]">
L139:               <label className="text-xs font-mono text-muted-foreground mb-1 block">Owner</label>
L140:               <Input
L141:                 data-testid="input-ci-owner"
L142:                 value={owner}
L143:                 onChange={(e) => setOwner(e.target.value)}
L144:                 placeholder="octocat"
L145:               />
L146:             </div>
L147:             <div className="flex-1 min-w-[120px]">
L148:               <label className="text-xs font-mono text-muted-foreground mb-1 block">Repository</label>
L149:               <Input
L150:                 data-testid="input-ci-repo"
L151:                 value={repo}
L152:                 onChange={(e) => setRepo(e.target.value)}
L153:                 placeholder="hello-world"
L154:               />
L155:             </div>
L156:             <Button type="submit" data-testid="button-ci-search">
L157:               <RefreshCw className="w-4 h-4 mr-2" />
L158:               Load Runs
L159:             </Button>
L160:           </form>
L161:         </Card>
L162: 
L163:         {hasSearch && (
L164:           <Card className="p-4 mb-6">
L165:             <div className="flex flex-wrap gap-2 items-end">
L166:               <div className="flex-1 min-w-[120px]">
L167:                 <label className="text-xs font-mono text-muted-foreground mb-1 block">Commit SHA</label>
L168:                 <Input
L169:                   data-testid="input-ci-sha"
L170:                   value={manualSha}
L171:                   onChange={(e) => setManualSha(e.target.value)}
L172:                   placeholder="abc123..."
L173:                 />
L174:               </div>
L175:               <div className="min-w-[100px]">
L176:                 <label className="text-xs font-mono text-muted-foreground mb-1 block">Ref</label>
L177:                 <Input
L178:                   data-testid="input-ci-ref"
L179:                   value={manualRef}
L180:                   onChange={(e) => setManualRef(e.target.value)}
L181:                   placeholder="main"
L182:                 />
L183:               </div>
L184:               <Button
L185:                 data-testid="button-ci-enqueue"
L186:                 variant="outline"
L187:                 onClick={() => enqueue.mutate()}
L188:                 disabled={!manualSha || enqueue.isPending}
L189:               >
L190:                 <Play className="w-4 h-4 mr-2" />
L191:                 {enqueue.isPending ? "Enqueuing..." : "Manual Enqueue"}
L192:               </Button>
L193:             </div>
L194:           </Card>
L195:         )}
L196: 
L197:         {isLoading && hasSearch && (
L198:           <div className="flex flex-col items-center justify-center h-[30vh] space-y-4">
L199:             <div className="w-12 h-12 border-4 border-primary/30 border-t-primary rounded-full animate-spin" />
L200:             <p className="text-muted-foreground font-mono animate-pulse">Loading runs...</p>
L201:           </div>
L202:         )}
L203: 
L204:         {hasSearch && !isLoading && runs.length === 0 && (
L205:           <div className="text-center py-20 border border-dashed border-border rounded-md">
L206:             <p className="text-muted-foreground">No CI runs found for {searchOwner}/{searchRepo}.</p>
L207:             <p className="text-xs text-muted-foreground mt-2">
L208:               Configure a GitHub webhook or use manual enqueue to trigger runs.
L209:             </p>
L210:           </div>
L211:         )}
L212: 
L213:         {!hasSearch && (
L214:           <div className="text-center py-20 border border-dashed border-border rounded-md">
L215:             <p className="text-muted-foreground">Enter a repository owner and name above to view CI runs.</p>
L216:           </div>
L217:         )}
L218: 
L219:         <div className="grid grid-cols-1 gap-3">
L220:           {runs.map((run, i) => (
L221:             <motion.div
L222:               key={run.id}
L223:               initial={{ opacity: 0, y: 10 }}
L224:               animate={{ opacity: 1, y: 0 }}
L225:               transition={{ delay: i * 0.03 }}
L226:             >
L227:               <Card
L228:                 className="p-4 hover-elevate cursor-default"
L229:                 data-testid={`card-ci-run-${run.id}`}
L230:               >
L231:                 <div className="flex flex-wrap items-center justify-between gap-3">
L232:                   <div className="flex items-center gap-3 flex-wrap">
L233:                     <CiStatusBadge status={run.status} />
L234:                     <span className="font-mono text-sm flex items-center gap-1 text-muted-foreground" data-testid={`text-ci-sha-${run.id}`}>
L235:                       <GitCommit className="w-3.5 h-3.5" />
L236:                       {run.commitSha.slice(0, 7)}
L237:                     </span>
L238:                     <span className="font-mono text-sm flex items-center gap-1 text-muted-foreground">
L239:                       <GitBranch className="w-3.5 h-3.5" />
L240:                       {run.ref}
L241:                     </span>
L242:                     <Badge variant="outline" className="no-default-hover-elevate no-default-active-elevate text-xs font-mono">
L243:                       {run.eventType}
L244:                     </Badge>
L245:                   </div>
L246:                   <div className="flex items-center gap-3 text-xs text-muted-foreground font-mono">
L247:                     <span className="flex items-center gap-1">
L248:                       <Clock className="w-3 h-3" />
L249:                       {formatDistanceToNow(new Date(run.createdAt), { addSuffix: true })}
L250:                     </span>
L251:                     {run.startedAt && run.finishedAt && (
L252:                       <span>
L253:                         {Math.round((new Date(run.finishedAt).getTime() - new Date(run.startedAt).getTime()) / 1000)}s
L254:                       </span>
L255:                     )}
L256:                     {run.status === "SUCCEEDED" && run.outDir && (
L257:                       <Link href={`/ci/runs/${run.id}`}>
L258:                         <Button size="sm" variant="ghost" data-testid={`button-view-dossier-${run.id}`}>
L259:                           <ExternalLink className="w-3.5 h-3.5 mr-1" />
L260:                           View
L261:                         </Button>
L262:                       </Link>
L263:                     )}
L264:                   </div>
L265:                 </div>
L266:                 {run.error && (
L267:                   <div className="mt-2 text-xs font-mono text-destructive bg-destructive/5 rounded-md p-2 break-all" data-testid={`text-ci-error-${run.id}`}>
L268:                     {run.error}
L269:                   </div>
L270:                 )}
L271:                 {run.summaryJson && (
L272:                   <div className="mt-2 flex flex-wrap gap-2">
L273:                     {run.summaryJson.boot_commands != null && (
L274:                       <span className="text-xs font-mono text-muted-foreground">boot: {run.summaryJson.boot_commands}</span>
L275:                     )}
L276:                     {run.summaryJson.endpoints != null && (
L277:                       <span className="text-xs font-mono text-muted-foreground">endpoints: {run.summaryJson.endpoints}</span>
L278:                     )}
L279:                     {run.summaryJson.gaps != null && (
L280:                       <span className="text-xs font-mono text-muted-foreground">gaps: {run.summaryJson.gaps}</span>
L281:                     )}
L282:                   </div>
L283:                 )}
L284:               </Card>
L285:             </motion.div>
L286:           ))}
L287:         </div>
L288: 
L289:         <div className="mt-12 border-t border-border pt-8">
L290:           <h2 className="text-lg font-display font-semibold mb-4 text-foreground" data-testid="text-webhook-setup-title">Webhook Setup</h2>
L291:           <Card className="p-4 font-mono text-sm space-y-3">
L292:             <div>
L293:               <span className="text-muted-foreground">URL:</span>{" "}
L294:               <code className="text-primary" data-testid="text-webhook-url">
L295:                 {window.location.origin}/api/webhooks/github
L296:               </code>
L297:             </div>
L298:             <div>
L299:               <span className="text-muted-foreground">Content type:</span>{" "}
L300:               <code>application/json</code>
L301:             </div>
L302:             <div>
L303:               <span className="text-muted-foreground">Events:</span>{" "}
L304:               <code>Push</code>, <code>Pull request</code>
L305:             </div>
L306:             <div>
L307:               <span className="text-muted-foreground">Secret:</span>{" "}
L308:               <code>Set GITHUB_WEBHOOK_SECRET env var</code>
L309:             </div>
L310:           </Card>
L311:         </div>
L312:       </div>
L313:     </Layout>
L314:   );
L315: }
