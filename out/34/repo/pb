#!/usr/bin/env python3
import argparse, os, re, shlex, subprocess, sys, json
from datetime import datetime, timezone
from pathlib import Path

# --- Policy (MVP conservative; expand later) ---
# --- Execution hardening (no shell) ---
ALLOWED_BINS = {"ls", "pwd", "whoami", "echo", "cat", "mkdir", "cp", "mv", "git", "python3", "pip", "openssl"}
SUSPICIOUS_TOKENS = {";", "&&", "||", "|", ">", ">>", "<", "<<", "`"}

def to_argv(cmd: str):
  argv = shlex.split(cmd, posix=True)
  if not argv:
    raise ValueError("empty command")
  if argv[0] not in ALLOWED_BINS:
    raise ValueError(f"binary not allowed: {argv[0]}")
  if any(tok in SUSPICIOUS_TOKENS for tok in argv[1:]):
    raise ValueError("suspicious shell token in args")
  return argv
ALLOWED_STARTS = (
  "cd ", "ls", "pwd", "echo ", "cat ", "mkdir ", "cp ", "mv ",
  "git ", "python3 ", "pip ", "openssl "
)

DANGEROUS_PATTERNS = [
  r"\bsudo\b",
  r"\brm\s+-rf\b",
  r"\bmkfs\b",
  r"\bshutdown\b",
  r"\breboot\b",
  r"\bchown\b",
  r"\bchmod\s+777\b",
  r"\|\s*sh\b",
  r"\|\s*bash\b",
  r">\s*/dev/",
  r"&>\s*/dev/",
  r"\bcurl\b.*\|\s*(sh|bash)\b",
  r"\bwget\b.*\|\s*(sh|bash)\b",
]

# Lines that are almost always "docs" not commands
DOC_PREFIXES = (
  "#", "```", "http://", "https://", "-", "*", "‚Ä¢", ">", "‚îÇ", "‚Äî", "===", "___"
)

DOC_HEADERS = {
  "bash", "zsh", "shell", "terminal", "example", "examples", "run:", "copy:", "use:", "usage:"
}

def now_utc():
  return datetime.now(timezone.utc).isoformat()

def read_stdin_text():
  return sys.stdin.read()

def read_clipboard_text():
  try:
    out = subprocess.check_output(["pbpaste"], text=True)
    return out
  except Exception as e:
    print(f"‚ùå Clipboard read failed (pbpaste). Error: {e}", file=sys.stderr)
    return ""

def looks_like_docs(line: str) -> bool:
  t = line.strip()
  if not t:
    return True
  lower = t.lower()

  if any(t.startswith(p) for p in DOC_PREFIXES):
    # allow "#!/usr/bin/env ..." only if it's a shebang
    if t.startswith("#!") and "python" in t:
      return False
    return True

  # common headers
  if lower in DOC_HEADERS:
    return True
  if lower.startswith("run this") or lower.startswith("copy this") or lower.startswith("note:"):
    return True

  # markdown code fences or bullets disguised
  if lower.startswith("```") or lower.endswith("```"):
    return True

  return False

def strip_code_fences(lines):
  out = []
  in_fence = False
  for ln in lines:
    t = ln.strip()
    if t.startswith("```"):
      in_fence = not in_fence
      continue
    if in_fence:
      # inside a code block, keep lines
      out.append(ln)
    else:
      out.append(ln)
  return out

def normalize_to_commands(text: str):
  lines = text.splitlines()
  lines = strip_code_fences(lines)

  cmds = []
  for ln in lines:
    raw = ln.rstrip("\n")
    t = raw.strip()

    if looks_like_docs(t):
      continue

    # remove leading bullet markers if present
    t = re.sub(r"^\s*[-*‚Ä¢]\s+", "", t).strip()

    # ignore empty after cleanup
    if not t:
      continue

    cmds.append(t)

  return cmds

def classify(cmd: str):
  # Dangerous?
  for pat in DANGEROUS_PATTERNS:
    if re.search(pat, cmd):
      return ("block", f"matches dangerous pattern: {pat}")

  # Allowed?
  if any(cmd.startswith(prefix) for prefix in ALLOWED_STARTS):
    return ("allow", "allowed by prefix allowlist")

  # Otherwise review
  return ("review", "not in allowlist (MVP is conservative)")

def render_plan(plan):
  print("PROMPT BOX (pb) ‚Äî plan")
  print("‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ")
  print(f"CWD:   {plan['cwd']}")
  print(f"Time:  {plan['timestamp']}\n")

  allow = sum(1 for c in plan["commands"] if c["verdict"] == "allow")
  review = sum(1 for c in plan["commands"] if c["verdict"] == "review")
  block = sum(1 for c in plan["commands"] if c["verdict"] == "block")

  print(f"‚úÖ ALLOW : {allow}")
  print(f"üü° REVIEW: {review}")
  print(f"‚õî BLOCK : {block}\n")

  for c in plan["commands"]:
    icon = "‚úÖ" if c["verdict"] == "allow" else ("üü°" if c["verdict"] == "review" else "‚õî")
    print(f"{icon} [{c['line']}] {c['raw']}")
    if c["verdict"] != "allow":
      print(f"   ‚Ü≥ {c['reason']}")
  print()

def build_plan(cmd_lines):
  commands = []
  for i, cmd in enumerate(cmd_lines, 1):
    verdict, reason = classify(cmd)
    commands.append({"line": i, "raw": cmd, "verdict": verdict, "reason": reason})

  return {
    "tool": "prompt-box",
    "mode": "",
    "timestamp": now_utc(),
    "cwd": str(Path.cwd()),
    "commands": commands,
    "results": [],
    "status": "planned",
  }

def write_receipt(plan, results):
  receipts = Path("receipts")
  receipts.mkdir(exist_ok=True)
  ts = int(datetime.now().timestamp())
  path = receipts / f"receipt_{ts}.json"
  receipt = dict(plan)
  receipt["results"] = results
  receipt["status"] = "executed"
  path.write_text(json.dumps(receipt, indent=2))
  return str(path)

def execute_allowed(plan):
  # read confirmation from /dev/tty so piping still works
  allowed_cmds = [c for c in plan["commands"] if c["verdict"] == "allow"]
  if not allowed_cmds:
    print("No allowed commands to run.")
    return 0

  print("Type YES to execute allowed commands:")
  try:
    with open("/dev/tty", "r") as tty:
      ans = tty.readline().strip()
  except Exception:
    ans = input("> ").strip()

  if ans != "YES":
    print("Cancelled (did not type YES).")
    return 0

  cwd = Path(plan["cwd"])
  results = []

  for c in allowed_cmds:
    cmd = c["raw"]

    # handle "cd" internally
    if cmd.startswith("cd "):
      target = cmd[3:].strip().strip('"').strip("'")
      target_path = Path(os.path.expanduser(target))
      if not target_path.is_absolute():
        target_path = (cwd / target_path).resolve()
      if target_path.exists() and target_path.is_dir():
        cwd = target_path
        results.append({"command": cmd, "cwd": str(cwd), "exit_code": 0})
      else:
        print(f"‚ùå cd failed: {target_path}")
        results.append({"command": cmd, "cwd": str(cwd), "exit_code": 1})
        receipt = write_receipt(plan, results)
        print(f"üìÑ Receipt: {receipt}")
        return 1
      continue

    # run command (NO SHELL)
    print("‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ")
    print(f"RUN: {cmd}")
    try:
      argv = shlex.split(cmd, posix=True)
      proc = subprocess.run(argv, shell=False, cwd=str(cwd), capture_output=True, text=True)
      code = proc.returncode
      if proc.stdout:
        print(proc.stdout, end="" if proc.stdout.endswith("\n") else "\n")
      if proc.stderr:
        print(proc.stderr, end="" if proc.stderr.endswith("\n") else "\n")
    except KeyboardInterrupt:
      code = 130
    except Exception as e:
      print(f"‚õî blocked at execution: {e}")
      code = 126

    results.append({"command": cmd, "cwd": str(cwd), "exit_code": code})
    if code != 0:
      print(f"‚ùå failed (exit {code})")
      receipt = write_receipt(plan, results)
      print(f"üìÑ Receipt: {receipt}")
      return code

  receipt = write_receipt(plan, results)
  print(f"\nüìÑ Receipt: {receipt}")
  return 0

def cmd_check(text):
  cmds = normalize_to_commands(text)
  plan = build_plan(cmds)
  plan["mode"] = "check"
  render_plan(plan)
  return 0

def cmd_run(text):
  cmds = normalize_to_commands(text)
  plan = build_plan(cmds)
  plan["mode"] = "run"
  render_plan(plan)
  return execute_allowed(plan)

def cmd_normalize(text):
  cmds = normalize_to_commands(text)
  # print ONLY cleaned commands, one per line
  for c in cmds:
    print(c)
  return 0

def cmd_ui():
  # Minimal UI: paste -> check/normalize/run (clipboard supported too)
  try:
    import tkinter as tk
    from tkinter import ttk, messagebox
  except Exception as e:
    print("‚ùå tkinter not available in this Python. Install a Python with tkinter (brew python often works).")
    print("Error:", e)
    return 1

  root = tk.Tk()
  root.title("Prompt-Box (pb)")

  frm = ttk.Frame(root, padding=10)
  frm.pack(fill="both", expand=True)

  ttk.Label(frm, text="Paste AI output here:").pack(anchor="w")

  text = tk.Text(frm, height=18, width=90)
  text.pack(fill="both", expand=True)

  out = tk.Text(frm, height=12, width=90)
  out.pack(fill="both", expand=True)
  out.insert("1.0", "Output will appear here.\n")

  def set_out(s):
    out.delete("1.0", "end")
    out.insert("1.0", s)

  def get_in():
    return text.get("1.0", "end")

  def do_check():
    from io import StringIO
    buf = StringIO()
    sys_stdout = sys.stdout
    sys.stdout = buf
    try:
      cmd_check(get_in())
    finally:
      sys.stdout = sys_stdout
    set_out(buf.getvalue())

  def do_normalize_copy():
    from io import StringIO
    buf = StringIO()
    sys_stdout = sys.stdout
    sys.stdout = buf
    try:
      cmd_normalize(get_in())
    finally:
      sys.stdout = sys_stdout
    cleaned = buf.getvalue()
    root.clipboard_clear()
    root.clipboard_append(cleaned)
    set_out(cleaned + "\n\n(Copied to clipboard)")
    messagebox.showinfo("pb", "Normalized commands copied to clipboard.")

  def do_run():
    # For safety, show plan first in output, then require YES in terminal (not UI)
    from io import StringIO
    buf = StringIO()
    sys_stdout = sys.stdout
    sys.stdout = buf
    try:
      cmds = normalize_to_commands(get_in())
      plan = build_plan(cmds)
      plan["mode"] = "run"
      render_plan(plan)
    finally:
      sys.stdout = sys_stdout
    set_out(buf.getvalue() + "\n\nNow run this in Terminal:\n\npb run <(pb clip normalize)\n")

  btns = ttk.Frame(frm)
  btns.pack(fill="x", pady=8)

  ttk.Button(btns, text="Check", command=do_check).pack(side="left")
  ttk.Button(btns, text="Normalize ‚Üí Copy", command=do_normalize_copy).pack(side="left", padx=8)
  ttk.Button(btns, text="Run (prints plan)", command=do_run).pack(side="left")

  # convenience: preload clipboard
  try:
    clip = read_clipboard_text()
    if clip.strip():
      text.insert("1.0", clip)
  except Exception:
    pass

  root.mainloop()
  return 0

def main():
  p = argparse.ArgumentParser(prog="pb")
  sub = p.add_subparsers(dest="cmd", required=True)

  # stdin-based
  sub.add_parser("check", help="read text from stdin; show allow/review/block")
  sub.add_parser("run", help="read text from stdin; show plan; execute allowed after YES")
  sub.add_parser("normalize", help="read text from stdin; output cleaned commands only")

  # clipboard-based
  clip = sub.add_parser("clip", help="use macOS clipboard (pbpaste) instead of stdin")
  clip_sub = clip.add_subparsers(dest="clip_cmd", required=True)
  clip_sub.add_parser("check")
  clip_sub.add_parser("run")
  clip_sub.add_parser("normalize")

  sub.add_parser("ui", help="open a paste-box UI")

  args = p.parse_args()

  if args.cmd == "ui":
    return cmd_ui()

  if args.cmd == "clip":
    text = read_clipboard_text()
    if args.clip_cmd == "check":
      return cmd_check(text)
    if args.clip_cmd == "run":
      return cmd_run(text)
    if args.clip_cmd == "normalize":
      return cmd_normalize(text)

  # default stdin path
  text = read_stdin_text()
  if args.cmd == "check":
    return cmd_check(text)
  if args.cmd == "run":
    return cmd_run(text)
  if args.cmd == "normalize":
    return cmd_normalize(text)

  return 1

if __name__ == "__main__":
  raise SystemExit(main())
