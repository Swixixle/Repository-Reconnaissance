Great — we now have enough raw material to make concrete calls, and you also accidentally revealed a few real bugs (the “line_start: 0” stuff, and the mangled command prompt output). Here’s the tight review.

# Ship/no-ship verdict (V1 deterministic mode)

**NO-SHIP until 3 fixes land.**
You’re close, but right now the evidence layer is still leaky in ways that will break trust.

---

# What’s good

### Evidence object shape

You’re outputting structured evidence objects with `path`, `line_start`, `line_end`, `snippet_hash`, `display`. ✅

### Completeness rubric is no longer inflated

`score: 62/100` with explicit missing items is realistic. ✅

### Replit execution profile is doing the right “operator manual” job

* `run_command` present
* env-port behavior inferred
* required secrets gathered with multi-file reference chains ✅

### Self-skip is correctly surfaced

Coverage shows `server/analyzer` excluded with counts and reason ✅

---

# Three blocking issues

## 1) **Evidence with `line_start: 0` is invalid**

In `external_apis` you have multiple evidence entries like:

```json
"line_start": 0,
"line_end": 0,
"display": "…:0"
```

That’s a hard fail for audit-grade claims. Line numbers must be **1-indexed** and must correspond to a real line in the file.

**Likely cause:** your “external API detector” is doing a pattern match without capturing line numbers, then stubbing 0. Or it’s in a pack manifest and not mapped back.

**Fix:**

* Every grep/pattern scan must record actual line numbers.
* If you can’t get line numbers, set evidence to `null` and mark the API as inferred with confidence cap 0.20.

**Rule:** If evidence can’t be cited properly, it doesn’t exist.

---

## 2) “Install Node dependencies → npm install” is not evidenced (and likely wrong)

Right now you justify `npm install` via `package.json:2`. That line is not “install steps”.

This is an important product question: **“HOW to use it”** must be grounded, not guessed.

**Fix options:**

### Option A (strict)

Only output install commands if they’re present in:

* README/docs
* `.replit` run/install section (if any)
* CI scripts
* Makefile

Otherwise: `install_steps: []` and add to missing.

### Option B (acceptable inference, but label it)

If `package-lock.json` exists → suggest `npm ci` (or `npm install`) as inferred.
If `pnpm-lock.yaml` exists → suggest `pnpm i`.
If `yarn.lock` exists → suggest `yarn install`.

But then the evidence must cite the **lockfile presence line** (which is a file existence fact; line-level evidence is weird there). Better: create an evidence type that allows `file_exists` receipts.

Example:

```json
"evidence": {"kind":"file_exists","path":"pnpm-lock.yaml","snippet_hash":"…"}
```

Right now you only support line ranges, so you’re trying to cite install steps from arbitrary line numbers. That’s brittle.

**Blocker because:** install steps are the core “how to use it” promise.

---

## 3) Replit mode is over-asserting “is_replit: true”

Coverage shows:

```json
"mode": "replit",
"is_replit": true
```

But earlier you correctly noted that `--root server` may not include `.replit`. In your pasted outputs, I don’t see `.replit` evidence. Yet you still set `is_replit: true`.

**Fix:**

* Split “run mode” from “detected replit config”.

Suggested fields:

```json
"mode_requested": "replit",
"replit_detected": true/false,
"replit_detection_evidence": [...]
```

Then set `replit_detected=true` only if `.replit` exists **or** other strong signals exist (replit.nix, REPLIT env usage, etc.), and include evidence.

Otherwise, it becomes marketing again.

---

# Additional non-blocking but important issues

### External API detection quality

You detect OpenAI and cite `script/build.ts` etc. But without valid line numbers (issue #1), it’s unusable. Fix that and also ensure the detector doesn’t just match “OpenAI” as a word; it should match import/module usage or URL patterns.

### Port binding “port: null”

This is fine if it’s env-driven. But the dossier/manual should explicitly spell it out:

* “Uses PORT env var; actual port determined at runtime. In Replit, PORT is injected.”

Add that sentence in the dossier/howto.

---

# What I need next (to finish security + rubric confirmation)

You still haven’t pasted **Block 4: safety functions** (the code dump). Without that I can’t confirm:

* path containment is correct
* symlink escape is prevented
* size cap is enforced before reading
* binary detection is sane

So paste Block 4 next.

---

# Exact agent instructions (copy/paste)

### Fix 1: ban line_start=0

> Audit all evidence generation: line_start and line_end must be >= 1.
> Any evidence with missing line numbers must be dropped or converted to a different evidence kind (e.g., file_exists).
> Add a validation pass that fails the run if any evidence object has line_start < 1.

### Fix 2: install steps must be evidenced or explicitly inferred

> Implement lockfile-based install inference:
>
> * package-lock.json → npm ci
> * pnpm-lock.yaml → pnpm i
> * yarn.lock → yarn install
>   If no lockfile and no docs instruction → install_steps empty and add to completeness missing.
>   Add a new evidence type `file_exists` or `path_only` for file existence claims (do not fake line numbers).

### Fix 3: separate requested mode vs detected replit

> In coverage.json and replit_profile.json, add:
>
> * mode_requested
> * replit_detected
> * replit_detection_evidence[]
>   Do not set replit_detected true unless `.replit` or `replit.nix` exists (or similar strong signal) with evidence.

### Provide Block 4 (safety code dump)

> Paste the literal output of the function dump for:
> `_safe_resolve_path`, `_read_line_from_repo`, `_parse_evidence_string`, `_verify_single_evidence`, `_compute_completeness`

---

When you paste Block 4, I’ll give you:

* a **security pass/fail** on the evidence hashing + containment layer
* final rubric tweaks
* updated ship verdict
