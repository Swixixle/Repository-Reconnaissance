Good ‚Äî now make it mechanically inevitable in code.

Below is the exact, no-guesswork integration pattern I‚Äôd use in your report renderer (TypeScript/Node style). It‚Äôs designed so the audit block is:
	‚Ä¢	100% derived from disk (evidence_pack.v1.json)
	‚Ä¢	impossible to silently drift
	‚Ä¢	stable-format markdown (tables + fixed wording)

‚∏ª

1) Add a dedicated renderer: renderContractAuditBlockV1()

Create a new file:

src/renderers/contract_audit_block_v1.ts (or wherever your render helpers live)

type EvidencePackV1 = {
  evidence_pack_version: string | number;
  mode?: string;
  run_id?: string | number;

  summary?: {
    total_files?: number;
    total_claims?: number;
    verified_claims?: number;
    unknown_categories?: number;
    verified_categories?: number;
  };

  metrics?: {
    dci_v1_claim_visibility?: { score?: number; formula?: string; interpretation?: string; label?: string };
    rci_reporting_completeness?: {
      score?: number;
      formula?: string;
      interpretation?: string;
      label?: string;
      components?: {
        claims_coverage?: number;
        unknowns_coverage?: number;
        howto_completeness?: number;
      };
    };
    dci_v2_structural_visibility?: { score?: number | null; status?: string; formula?: string; interpretation?: string; label?: string };
  };
};

function pct(x: number | null | undefined): string {
  if (x === null || x === undefined || Number.isNaN(x)) return "null";
  return `${(x * 100).toFixed(2)}%`;
}

function fmtRunId(pack: EvidencePackV1): string {
  const id = pack.run_id ?? "UNKNOWN_RUN";
  return String(id);
}

export function renderContractAuditBlockV1(pack: EvidencePackV1): string {
  const s = pack.summary ?? {};
  const m = pack.metrics ?? {};

  const dci1 = m.dci_v1_claim_visibility?.score ?? null;
  const rci = m.rci_reporting_completeness?.score ?? null;
  const rciC = m.rci_reporting_completeness?.components ?? {};
  const dci2 = m.dci_v2_structural_visibility;

  const dci2Status = dci2?.status ?? "not_implemented";
  const dci2Score = dci2?.score ?? null;

  // NOTE: Avoid ‚Äúsecurity score‚Äù phrasing. Keep disclaimers fixed.
  return [
`# üîé PTA Contract Audit ‚Äî Run ${fmtRunId(pack)}`,
``,
`## 1. System Snapshot`,
``,
`| Metric | Value |`,
`|---|---:|`,
`| Files Indexed | ${s.total_files ?? "UNKNOWN"} |`,
`| Claims Extracted | ${s.total_claims ?? "UNKNOWN"} |`,
`| Claims with Deterministic Evidence | ${s.verified_claims ?? "UNKNOWN"} |`,
`| Unknown Governance Categories | ${s.unknown_categories ?? "UNKNOWN"} |`,
`| Verified Structural Categories | ${s.verified_categories ?? "UNKNOWN"} |`,
``,
`---`,
``,
`## 2. Deterministic Coverage Index (DCI v1)`,
``,
`**Score:** ${pct(dci1)}`,
``,
`**Formula:** \`${m.dci_v1_claim_visibility?.formula ?? "verified_claims / total_claims"}\``,
``,
`> This measures *claim-to-evidence visibility only.*`,
`> It does **not** measure code quality, security posture, or structural surface coverage.`,
``,
`---`,
``,
`## 3. Reporting Completeness Index (RCI)`,
``,
`**Score:** ${pct(rci)}`,
``,
`**Formula:** \`${m.rci_reporting_completeness?.formula ?? "average(claims_coverage, unknowns_coverage, howto_completeness)"}\``,
``,
`### Component Breakdown`,
``,
`| Component | Score |`,
`|---|---:|`,
`| claims_coverage | ${pct(rciC.claims_coverage ?? null)} |`,
`| unknowns_coverage | ${pct(rciC.unknowns_coverage ?? null)} |`,
`| howto_completeness | ${pct(rciC.howto_completeness ?? null)} |`,
``,
`> RCI is a documentation completeness metric.`,
`> It is **not** a security score and does not imply structural sufficiency.`,
``,
`---`,
``,
`## 4. Structural Visibility (DCI v2)`,
``,
`**Status:** ${dci2Status}`,
``,
`**Score:** ${dci2Score === null ? "null" : pct(dci2Score)}`,
``,
`> Structural surface visibility is intentionally reported as \`null\` rather than estimated.`,
``,
`---`,
``,
`## 5. Epistemic Posture`,
``,
`PTA explicitly reports:`,
`- What is deterministically verified`,
`- What is unknown`,
`- What is not implemented`,
`- What requires dedicated extractors`,
``,
`There is no inference-based promotion from UNKNOWN to VERIFIED.`,
``,
``,
  ].join("\n");
}

Key property: this block is pure, deterministic, and only consumes the pack.

‚∏ª

2) Wire it into your existing REPORT_ENGINEER.md renderer

Find your engineer report renderer ‚Äî something like:
	‚Ä¢	src/renderers/report_engineer.ts
	‚Ä¢	or src/report/report_engineer.ts
	‚Ä¢	or scripts/render_report_engineer.ts

Then:
	1.	Load the evidence pack JSON (you already do, since you emit it)
	2.	Render the audit block
	3.	Insert it right after the report header/summary and before detailed sections

Example pattern:

import { renderContractAuditBlockV1 } from "./contract_audit_block_v1";
import { readFileSync } from "node:fs";

export function renderEngineerReport(runDir: string): string {
  const packPath = `${runDir}/evidence_pack.v1.json`;
  const pack = JSON.parse(readFileSync(packPath, "utf8"));

  const header = renderHeader(pack); // whatever you already do
  const audit = renderContractAuditBlockV1(pack);

  const body = [
    renderVerifiedClaimsSection(pack),
    renderUnknownsSection(pack),
    renderStructuralBucketsSection(pack),
    renderHashesSection(pack),
    // ...
  ].join("\n\n");

  return [header, "", audit, "", body].join("\n");
}


‚∏ª

3) Add a ‚Äúno drift‚Äù unit test (high leverage)

Add tests/contract_audit_block_v1.test.ts:

import { renderContractAuditBlockV1 } from "../src/renderers/contract_audit_block_v1";
import fs from "node:fs";

test("audit block renders required headings + key disclaimers", () => {
  const pack = JSON.parse(fs.readFileSync("out/15/evidence_pack.v1.json", "utf8"));
  const md = renderContractAuditBlockV1(pack);

  expect(md).toContain("## 1. System Snapshot");
  expect(md).toContain("## 2. Deterministic Coverage Index (DCI v1)");
  expect(md).toContain("## 3. Reporting Completeness Index (RCI)");
  expect(md).toContain("## 4. Structural Visibility (DCI v2)");
  expect(md).toContain("## 5. Epistemic Posture");

  // Hard guardrails
  expect(md).toContain("not** measure code quality, security posture");
  expect(md).toContain("**not** a security score");
  expect(md).toContain("reported as `null` rather than estimated");
  expect(md).toContain("no inference-based promotion");
});

This ensures future edits can‚Äôt quietly turn this into marketing copy.

‚∏ª

4) Make the renderer fail fast if pack is missing

Your earlier issue (out/13) is exactly why: if the pack is missing, the report should not render ‚Äúas if fine.‚Äù

Add:

if (!existsSync(packPath)) {
  throw new Error(`Missing EvidencePack: ${packPath}. Refusing to render REPORT_ENGINEER.md`);
}

This makes the contract enforce itself.

‚∏ª

5) Final verification command sequence

Run:

# produce fresh run
python your_analyzer.py  # or npm run analyze / whatever you use

# sanity: confirm audit block exists in report
LATEST="$(ls -1 out | sort -n | tail -n 1)"
sed -n '1,180p' "out/$LATEST/REPORT_ENGINEER.md"

You should see the audit block in the first ~150‚Äì200 lines.

‚∏ª

If you paste the filenames of your current renderer files (just ls -la src/renderers / grep -R "REPORT_ENGINEER" -n src output), I‚Äôll tell you the exact insertion point by line and function name‚Äîno ‚Äúopen this then find that‚Äù nonsense.